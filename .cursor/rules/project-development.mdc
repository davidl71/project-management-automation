# Project Management Automation - Development Rules

This document provides development guidelines and conventions for the Project Management Automation MCP Server.

## Project Overview

**Type**: Python MCP Server
**Purpose**: Expose project management automation tools via Model Context Protocol
**Package Name**: `exarp` (Extended Automation & Research Platform)
**MCP Server Identifier**: `exarp`

## Code Style

- **Python Version**: >= 3.9
- **Code Formatter**: Black (default configuration)
- **Linter**: Ruff
- **Type Checking**: mypy (strict mode recommended)
- **Testing**: pytest with pytest-mock

## Development Workflow

### 1. Setup Development Environment

**ðŸš¨ CRITICAL: This project uses `uv` for package management. NEVER use `pip` directly.**

```bash
# Install dependencies and sync environment (REQUIRED - uses uv.lock)
uv sync

# This replaces the old: pip install -e '.[dev]'
# uv automatically handles editable installs and dev dependencies
```

**Why `uv`?**
- 10-100x faster than pip
- Automatic environment management
- Better dependency resolution
- Project has `uv.lock` file configured

**If `uv` is not available:**
```bash
# Install uv first
curl -LsSf https://astral.sh/uv/install.sh | sh
# Or: pipx install uv
```

### 2. Running Tests

**Always use `uv run` to execute commands in the managed environment:**

```bash
# Run all tests
uv run pytest tests/ -v

# Run specific test file
uv run pytest tests/test_tools.py -v

# Run with coverage
uv run pytest tests/ --cov=project_management_automation --cov-report=html
```

### 3. Code Quality Checks

**Always use `uv run` to execute commands in the managed environment:**

```bash
# Format code
uv run black .

# Type check
uv run mypy .

# Lint
uv run ruff check .
```

### 4. Testing MCP Server

**Always use `uv run` to execute commands in the managed environment:**

```bash
# Run server directly for testing
uv run python -m project_management_automation.server

# Or use the exarp command
uv run exarp --version
```

## ðŸš¨ CRITICAL: FastMCP Return Type Requirements

**ALL MCP tools and resources MUST return JSON strings, NEVER dicts.**

See `.cursor/rules/fastmcp-return-types.mdc` for detailed requirements and patterns.

**Quick check before committing:**
```bash
uv run pytest tests/test_fastmcp_return_types.py -v
```

## Project Structure

```
project-management-automation/
â”œâ”€â”€ project_management_automation/  # Main package
â”‚   â”œâ”€â”€ server.py                   # MCP server entry point
â”‚   â”œâ”€â”€ tools/                      # Tool implementations
â”‚   â”œâ”€â”€ resources/                  # Resource handlers
â”‚   â””â”€â”€ scripts/                    # Automation scripts
â”œâ”€â”€ tests/                          # Test suite
â”‚   â””â”€â”€ test_fastmcp_return_types.py  # FastMCP return type validation
â”œâ”€â”€ docs/                           # Documentation
â””â”€â”€ pyproject.toml                  # Package configuration
```

## Tool Development Guidelines

### Adding New Tools

1. **Create tool implementation** in `tools/` directory
2. **Register tool** in `server.py` using FastMCP decorator
3. **Write tests** in `tests/test_tools.py`
4. **Document** tool in README.md and USAGE.md

### Tool Pattern

**ðŸš¨ CRITICAL: All tools MUST return JSON strings, not dicts.**

```python
from fastmcp import FastMCP
import json

mcp = FastMCP("exarp")

@mcp.tool()
def my_new_tool(
    param1: str,
    param2: Optional[int] = None
) -> str:  # âœ… MUST return str, not dict
    """
    Tool description.
    
    Args:
        param1: Description
        param2: Optional description
        
    Returns:
        str: JSON string with result or error
    """
    try:
        # Tool logic
        result = {"success": True, "data": {...}}
        # âœ… ALWAYS convert to JSON string
        return json.dumps(result, indent=2)
    except Exception as e:
        # âœ… ALWAYS return JSON string, even for errors
        return json.dumps({"success": False, "error": str(e)}, indent=2)
```

**Defensive Pattern (Recommended):**
```python
@mcp.tool()
def my_tool(...) -> str:
    """Tool description."""
    try:
        result = some_function()
        # Ensure we always return a JSON string
        if isinstance(result, str):
            return result
        elif isinstance(result, dict):
            return json.dumps(result, indent=2)
        else:
            return json.dumps({"result": str(result)}, indent=2)
    except Exception as e:
        return json.dumps({"error": str(e)}, indent=2)
```

**Why?**
- FastMCP expects strings, not dicts
- Prevents "object dict can't be used in 'await' expression" errors
- Ensures consistent return types across all tools/resources

## Error Handling

All tools should use centralized error handling via `error_handler.py`:

```python
from project_management_automation.error_handler import handle_error

try:
    # Tool logic
    pass
except Exception as e:
    return handle_error("TOOL_ERROR", str(e))
```

## Testing Requirements

- **Unit Tests**: All tools must have unit tests
- **Integration Tests**: Test MCP server integration
- **Mocking**: Use pytest-mock for external dependencies
- **Coverage**: Aim for 80%+ code coverage

## Documentation

- **Code Comments**: Use docstrings for all public functions
- **Type Hints**: Required for all function parameters and returns
- **README**: Keep README.md updated with installation and usage
- **USAGE.md**: Document all available tools and resources

## Dependencies

### Required
- `fastmcp>=2.0.0` - FastMCP framework
- `pydantic>=2.0.0` - Data validation

### Dev Dependencies
- `pytest>=7.0` - Testing framework
- `pytest-mock>=3.10.0` - Mocking utilities
- `black>=23.0` - Code formatter
- `mypy>=1.0` - Type checker
- `ruff>=0.1.0` - Linter

## MCP Server Configuration

### Exarp Server

```json
{
  "mcpServers": {
    "exarp": {
      "command": "uvx",
      "args": ["exarp"]
    }
  }
}
```

Or for development with hot-reload:

```json
{
  "mcpServers": {
    "exarp": {
      "command": "uv",
      "args": ["run", "python", "-m", "project_management_automation.server"],
      "env": {
        "EXARP_DEV_MODE": "1"
      }
    }
  }
}
```

### Complementary MCP Servers

```json
{
  "mcpServers": {
    "tractatus_thinking": {
      "command": "npx",
      "args": ["-y", "tractatus-thinking-mcp"]
    },
    "sequential_thinking": {
      "command": "uvx",
      "args": ["sequential_thinking"]
    }
  }
}
```

## Task Management

**ðŸš¨ CRITICAL: Use agentic-tools MCP for ALL task operations.**

**NEVER directly edit `.todo2/state.todo2.json` or any Todo2 files.**

**Available MCP Tools:**
- `mcp_agentic-tools_create_task` - Create new tasks
- `mcp_agentic-tools_update_task` - Update existing tasks
- `mcp_agentic-tools_list_tasks` - List tasks
- `mcp_agentic-tools_get_task` - Get task details
- `mcp_agentic-tools_delete_task` - Delete tasks (with confirmation)

**Example:**
```python
# âœ… CORRECT: Use MCP tool
mcp_agentic-tools_create_task(
    workingDirectory="/path/to/project",
    projectId="project-id",
    name="Task name",
    details="Task details",
    status="pending",
    priority=5,
    tags=["tag1", "tag2"]
)
```

**Why?**
- Ensures proper validation and consistency
- Maintains task relationships and metadata
- Works with the project's task management system
- Follows the established architecture

## Related Documentation

- `README.md` - Project overview and installation
- `USAGE.md` - Tool usage guide
- `DEPENDENCIES.md` - Complementary MCP servers
- `CONTRIBUTING.md` - Contribution guidelines
